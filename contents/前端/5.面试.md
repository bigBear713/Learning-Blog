1. 看用过哪些前端框架，它们之间有什么不同。如果让你做技术选型，你会怎么选？
- 考察: 技术的广度，以及对目前主流前端框架的了解程度。技术选型则需要从多个方面、多个角度进行综合评估，可以考察候选人思考问题是否全面。
- 答案：
    1. 如果只会vue或者react，则会的有点少。国内vue和react会比较流行，大部分人这两个都用过，可以说一下它们之间的相同点和不同点。
    2. 技术选型需要从公司的成本(是否好招人)，框架的生态(组件库、插件是否丰富等)，是否符合公司业务场景（比如还需要运行在移动端、小程序等）、学习曲线(是否易上手等)、框架的设计思想以及带来的代码风格（React的函数式思想更灵活，但也更难把控；vue2的类angularjs的选项式和vue3类react hooks的组合式，总是更贴近开发者的思维习惯，更好上手，但是也更割裂，风格多变；angular偏向后端的设计思想，更严谨，但入门门槛高）。
   
2. 如果后端人react用的比较多，问下react的class组件和函数式组件的不同，为啥react又要推出函数式组件？候选人更偏向哪种风格？
- 考察：React的掌握情况，以及框架背后的设计思想。还有候选人对框架的一些思考。
- 答案：
  1. class组件和函数式组件，主要是数据状态的差异，此外还有一些其它方面的不同（比如生命周期等）。函数式体现了react官方“数据不可变性（无副作用）”和“无状态”等设计思想
  2. 一般来说都会偏向函数式组件，官方也更推荐。但class组件也有可取之处，没有一定的答案。主要看后端人有没有自己的思考；还是因为人云亦云，因为官方推荐、大众流行而选择

3. react的hook为什么不能在条件、循环等语句等中使用？
- 考察：react掌握深度，看是否了解react本身运行的原理
- 答案：
  1. 如果回答了链表，说明掌握还行。如果有提到fiber架构，是比较好的。每个fiber节点都有自己的hook链表

4. 可以从上面的问题引申出fiber架构，询问这个架构是为了解决什么场景下的问题？看后端人对这个架构的了解程度
- 考察：对react的掌握情况，对react设计思想的了解程度
- 答案：
  1. 主要是fiber架构能够随时中断和继续组件的解析和渲染。在这个架构之前，组件树的解析和渲染是递归的，不能被打断和恢复，如果应用程序组件太多，容易造成白屏、卡顿，影响用户体验。fiber架构主要是有链表结构，每个fiber存有下个节点的指针。这样在某个节点停止后，可以在需要的时候找到下个节点，继续解析和渲染。

5. 使用过哪些hooks？有没有使用过useLayoutEffect，和useEffect有什么区别？它们和class组件中的componentDidMount生命周期有啥联系？
- 考察：react的使用情况，以及useEffect、useLayoutEffect这两个常用又相似hook的了解程度
- 答案：
  1. react中有很多hook，其中比较常用的有useState, useEffect, useCallback, useMemo, useContext...
  2. useEffect, useLayoutEffect这两个都是在依赖的属性值发生变化时执行一些更新操作。区别是：useEffect是在React将更新后的DOM绘制到浏览器后执行，是异步的，不会阻塞浏览器进程。而useLayoutEffect则是在React进行dom diff，得到要更新的DOM后，将它们绘制到浏览器之前执行，是同步的，会阻塞浏览器进程。
  3. 当依赖数组为空的时候，useLayoutEffect的效果会更接近componentDidMount的表现，它们都是同步执行且阻碍真实的DOM渲染

6.  React有啥性能优化的手段，知道啥最佳实践
- 考察：开发者是否有意识去改进自己的代码，提升自己的代码质量
- 答案：
  1. 减少render的次数，比如重写shouldComponentUpdate来避免不必要的dom操作
  2. PureComponent 是React官方提供的，为含有大量组件的项目准备的类，内部已经实现了重写shouldComponentUpdate这种机制，只需要让class组件继承它就行。至于函数组件，则需要使用高阶函数 memo 对其进行包裹
  3. 循环列表中使用key来帮React更快的进行diff
  4. 使用useCallback, useMemo对结果进行缓存，毕竟重复计算
  5. 使用Fragment减少额外的dom节点渲染
  6. 使用lazy 和 Suspense 互相配合，对组件进行懒加载
  7. 减少使用通过内联函数绑定事件。class组件就是将内联函数定义为类方法传递给子组件，函数组件是使用useCallback进行缓存
  8. 使用虚拟列表，只渲染需要的内容，无效内容不渲染出来，可以使用 React-virtualized 等第三方库

7.  React中的高阶组件是什么？什么场景下使用？vue相同场景下怎么解决
- 考察：对高阶组件的理解，以及对其它框架的掌握情况，通过相同场景下的解决方案来体现
- 答案：
  1. 高阶组件是一个函数，参数是组件，返回值也是一个组件，主要用于逻辑复用，强化组件，提升渲染性能等
  2. 针对逻辑复用，提升渲染性能等，vue中想实现类似效果时，可以用slot插槽。

9.  什么是受控组件，什么是非受控组件？什么时候使用
- 考察：基础知识
- 答案：
  1. 受控组件：组件的值等状态，全程响应外部数据，即通过外部属性进行控制
  2. 非受控组件：一般情况是在初始化的时候接受外部数据，然后自己在内部存储其自身状态，在需要的时候，通过获取该组件、标签元素来获取所需要的值
  3. 主要是在表单中使用。大部分场景下推荐使用受控组件，让React组件负责处理，缺点就是代码会多一些。如果使用非受控组件，控制能力比较弱，dom自身处理比较多，相对代码量少，更便捷

10. 虚拟dom是什么？优缺点有哪些？react，vue2和vue3的差异算法有啥区别
- 考察：基本知识，以及和vue2,vue3的对比，考察知识广度
- 答案：
  1. 不管是react，还是vue，VDOM就是一个 JS 对象, 通过一个对象来描述了每个 DOM 节点的特征，比如属性、值等。每次更新，都是先对这些Object对象dom进行diff，找出差异，再根据差异结果操作真实的dom，来达到提升性能的目的。缺点是有时候没有直接操作dom快，因为它需要先经过diff计算；首次渲染时，因为vdom还没建立，建立过程需要花费一定的时间；
  2. react的diff算法：只进行同一层级的比较。component级会判断是否同一个类型的组件，是就继续往下计算，不是就删除这个组件下的所有子节点；element级，同级比较，据每个节点在对应层级的唯一 key 作为标识进行比较，所以 key 在循环列表中很有用，也不能随便使用数组索引作为key
  3. vue2的diff算法：使用的是双端diff算法，同时比较新旧两组节点的双端的算法（比头、比尾、比头尾、比尾头），般情况下，先找出变更后的头部，在对剩下的进行双端diff
  4. vue3的diff算法：使用的是快速diff算法，鉴了文本diff算法的预处理思路。处理新旧两组节点中相同的前置节点和后置节点。当前置节点和后置节点都处理完后，如果无法通过简单的挂载新节点或卸载已经不存在的节点来更新，则需要根据节点间的索引关系，构造出一个最长递增子序列。最长递增子序列所指向的节点即不需要移动的节点
  5. 所以vue2/3中，循环列表中key也是非常重要的，有助于快速计算前后两次的dom改动

11.  vue3相比vue2做了哪些改变和提升
- 考察：对vue3的关注，基础知识
- 答案：    
  1. 体积更小，移除一些少用的api，引入tree-shaking摇树优化
  2. 编译更快：diff算法优化，事件监听缓存
  3. 对ts更好的支持
  4. 兼顾option API的同时，还推出composition API
  5. 使用Proxy来做属性的响应，而不再是Object.defineProperty。因为Object.defineProperty不能检测对象属性的添加和删除，同时在面对嵌套层级比较深的情况下，就存在性能问题
  6. 更好的逻辑复用。vue2中通过mixin实现功能混合，会导致命名冲突和数据来源不清晰。vue3中通过composition API，和 react 的 hook 类似的东西来实现逻辑复用

12. vue3使用了proxy，有什么缺点、局限吗
- 考察：对vue3语法的熟悉程度，基础知识    
- 答案：
  1. Proxy只能监听引用类型的数据的属性的改变，不能监听原始类型的数据的值的改变。
  2. 无法代理内部插槽，许多内建对象，例如 Map，Set，Date，Promise 等，都使用了所谓的“内部插槽”。
  3. 使用proxy代理后，得到的是一个代理对象，因此肯定不等于原本的值，在作比较的时候要注意

13. vue中，有什么常用的性能优化手段
- 考察：开发者是否有意识去改进自己的代码，提升自己的代码质量
- 答案：
  1. 使用computed计算属性，在依赖值改变时，才重新计算，然后将值缓存以便下次直接使用
  2. 对组件使用keep-alive，进行缓存
  3. 路由懒加载，组件懒加载
  4. 长列表使用虚拟滚动

14. vue3为什么使用hooks，为了解决什么问题
- 考察：hooks的使用场景，了解框架设计思想    
- 答案：
  1. 为了更改的进行逻辑的复用
  2. 解决使用mixin带来的变量名冲突，来源不清晰等问题

15.  Vue中对keep-alive的理解
- 考察：基础知识，优化手段
- 答案：
  1. keep-alive能在组件切换过程中将状态保留在内存中，防止重复渲染DOM, 它包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们
  2. 某些场景下不需要让页面重新加载时可以使用keep-alive
  3. 缓存后，还原时可以通过beforeRouteEnter或者actived钩子来重新获取数据
  4. 缓存太多也会占据太多的内存，因此不是无脑缓存

16. vue2中，为什么为一个对象添加新的属性，不会触发页面的更新
- 考察：vue2的响应原理
- 答案：
  1. vue2是用过Object.defineProperty实现数据响应式，会在一开始对对象添加setter,getter，而新增的属性不会自动添加setter,getter,所以给对象新增属性时，vue检测不到数据的改变。

17. 大概说一下，如何开发一个xx组件
- 考察： 需要有高内聚，低耦合的意识, 遵守单一职责
- 答案：    
  1. 

18.  大概说下router中，hash模式和history的差别，以及大概说下实现原理
- 考察：router路由实现的掌握情况

19. css中，box-sizing有哪两种值，它们的区别是啥
- 考察：css的基本知识
- 答案：有 content-box 标准盒子模型，以及 border-box 怪异 盒子模型
  1. content-box: width,height是只包含内容区域，不包含padding, border的
  2. border-box: width,height包含了padding和border，不包含margin

20. 子元素是浮动，为什么父元素加overflow:hidden就能够正常计算高度？
- 考察：BFC的相关知识点   


21. css中，绝对定位的位置是怎么计算的
- 考察：绝对定位，相对定位的位置计算
- 答案：相对定位是相对于它自身原本位置的左上角进行计算；绝对定位并未脱离文档流。绝对定位是相对于离它最近的某一个不为`static`的父元素的左上角位置进行定位，如果没有这样的父元素，就一直往上直到body；决定定位已经脱离了文档流。

22. css中伪元素是什么，伪类呢？
- 考察：对伪元素和伪类的掌握情况
- 答案：伪元素，是不存在的同时又具有一些元素特性的元素，主要是`::before`和`::after`。它们并不是一个真实存在的元素，但是又可以设置它们的宽高等一些元素的特征。
        伪类，是一些特殊存在的样式状态类，比如`:hover`和`:empty`等。它们并不是一个开发者自定义的样式类，而是一种约定的特殊存在的样式类。

23. 说一下css中，样式选择器优先级的怎么看
- 考察：css样式的优先级计算，如何写好样式
- 答案：样式选择器的优先级如果有`!important`则优先级最高，否则正常情况下由：A,B,C,D 这4个维度来进行计算：从左往右依次进行比较。较大者胜出；如果相等，则继续往右移动一位进行比较。如果4位全部相等，则后者会覆盖前面的
      1. A：通常情况下，A=0。当有内联样式时，A=1
      2. B: 为`ID选择器`出现的次数
      3. C: 为`类选择器`，`属性选择器`和`伪类选择器`出现的次数
      4. D: 为`标签选择器`和`伪元素选择器`出现的次数 

1.  哪些样式会引起重排，哪些样式会引起重绘，为什么？
- 考察：对页面渲染的掌握情况，以便写出高性能的页面    
- 答案：当影响元素标签之间的排列的情况下，会引起重排reflow，比如调整`width`、`display`等；当只影响元素标签自身的样式的情况下，则只会引起重绘repain，比如调整`color`、`visibility`等。
      1. 常见的引起reflow的操作：浏览器窗口大小改变、元素尺寸大小改变、元素字体大小发生改变、添加删除`可见`的dom元素，查询某些元素或者调用某些方法（如getComputedStyle()）
      2. 常见引入repain的操作：改变`color`，`background-color`等
      3. 因为 reflow 肯定伴随着 repain，repain 不一定有 reflow，因此 reflow 的代价会更高。浏览器为了性能考虑，一般会对频繁 relow 做优化：维护一个队列，将会引起 reflow 的操作放到这个队列中，在一定时间间隔或者达到一定条件后，一次性对这队列中的操作做一次处理，以此来避免频繁的 reflow。
      4. 当访问一些属性或者方法时，为了结果的准确性，客户端会立即执行优化队列中的操作，避免程序获取到错误的值。因此，除非有必要，尽量少访问这些属性或者方法：getComputedStyle()，width，clientWidth...

1.  大概说一下一个页面，从输入url开始访问到完整展示的过程
- 考察：对整个页面的生命周期的掌握情况
- 答案：首先是将url解析成ip地址，再通过ip地址找到对应的服务器。因为url其实是一串易于记忆的字符串，是ip地址的别名，ip地址才是真正能够唯一能够找到服务器的凭借。url解析成ip地址后，会在本地缓存，以便下次访问的时候快速解析，而不用每次都根据根域名、一级域名、二级域名等层层解析。
        其次是客户端和服务器通过 3 次握手，建立起连接，这样客户端才能像服务器请求数据，服务器才能响应数据给客户端。
        然后是服务器将页面等数据传送给客户端。客户端在接收到数据后开始进行解析。将html文件中的 html标记、js中的dom api解析生成 dom 树；将css文件中的css、js中的css api解析生成 cssom 树；将dom树和cssom树结合生成渲染树；客户端开始进行reflow和repain
        最后连接结束，进行4次挥手，结束tcp连接

1.  http怎么建立连接和断开连接。https为什么更安全，它绝对安全吗？
- 考察：对http的基本掌握情况
- 答案：http建立tcp连接需要经历3次握手：客户端发起建立连接请求，服务器响应请求并发送确认信息，客户端接收确认信息并发送确认信息后开始建立tcp连接；http结束tcp请求需要经历4次挥手：客户端发送关闭连接请求，服务器开始准备关闭连接并通知请求已收到，服务器发送可以关闭的信号，客户端接收到并发送连接已关闭的信号
        https是http+ssl，跟普通http相比多了ssl协议，主要是在建立连接时，通过ssl协议建立起一个对消息进行加密的机制（私钥、公钥）来确保消息就算被劫持也能保证安全。https并不是绝对安全，一些手段仍能绕过这种机制。

1.  http跨域是怎么解决的
- 考察：对http的跨域掌握是否全面
- 答案：跨域是客户端因为同源策略，对来自其它源的数据不进行响应而产生的一种现象，保证安全。解决方案
      1. 使用jsonp。基于js一般没有同源限制，请求时带上callback回调方法名，服务器将所需的数据传入该回调函数，让客户端能够正确读取。这种方法只能用于get请求，限制比较多
      2. 使用代理。跨域的产生，是客户端和服务器不在一个域里面，会有一些安全隐患。但是服务器之间就没有这种问题。因此通过在客户端同一个域中，使用一个服务器作为中间层，代为处理来自客户端的请求和来自真实服务器的响应，来实现功能的正常使用。目前前后端分类工程化开发，前端本地开发就是使用代理的方案
      3. 使用cors跨域资源共享。默认情况下，客户端不处理来自非同源的服务器的数据。但如果响应的结果已经表明，不需要遵守严格的同源同域限制，那客户端和服务器也能正常进行数据交换。这种做法，是接口在response header中设置了`Accept-Control-Arrow-Origin`

1.  301和302有啥区别，304代表了啥？4开头的状态码主要用在什么场景？401，403有什么区别？5开头的状态码主要用在什么场景？
- 考察：http状态码的掌握情况，有助于日常开发问题的排查
- 答案：301代表永久移动，主要用于一些资源已经永久移动到新的uri；302代表临时移动，主要用于一些资源因为服务器升级等原因临时由另外的服务器进行响应等。304代表数据没有发生变化，可以直接使用前一次返回的数据，主要用于协商缓存场景中。
        4xx状态码主要用于客户端自身的一些错误。比如400是错误请求，401是用户还没进行身份认证，403是用户没访问权限，404是来自客户端的请求地址找不到相关资源等。401是用户还没进行身份认证，403是用户已经认证过但没访问的权限。
        5xx状态码主要用于服务器自身的一些错误。比如500是服务器内部错误；501是接口请求未实现；502是网关执行请求时，从服务器未能得到一个有效的响应；503是服务器过载，崩溃；504是网关在向服务器执行请求时，服务器未能在规定的时间内给出响应

1.  浏览器缓存都有哪些？都在什么场景下使用？
- 考察：浏览器缓存的掌握，可以进行前端的优化，与问题的排查
- 答案：浏览器缓存主要有3中：无缓存，协商缓存，强缓存
    1. 无缓存：即不进行数据的缓存，比如api接口等场景下使用
    2. 协商缓存：每次都会进行http请求，如果数据没有变化，则返回304状态码和空的数据体，以便节省带宽，更快的进行数据的响应。服务器判断数据是否发生变化的依据，是`last-modified`和`etag`。last-modifyed是上次修改的时间。每次数据被更改时，都会生成一个新的modified时间。通过对比这个时间来判断时间是否发生了更改。etag是数据的唯一标识符，只要数据发生了更改，就会重新生成一个etag。通过对比etag也能判断数据是否发生了更改。如果两者同时存在，etag的优先级更高，因为更精确，但是对服务器负担也相对更重一些
    3. 强缓存：并没有每次都会进行http请求。会根据响应的标识来判断，在需要的时候才发起http请求，否则直接使用缓存在浏览器的数据。判断的标识在http1.0中使用`expired`。但是这种因为直接记录的是过期的年月日，很容易受电脑本地时间等因素的影响，已经逐渐被废弃。在http2.0中，主要是在response header中的`cache-control`的一些字段来判断。其中`max-age`是设定了数据缓存的有效期，单位是**s**，`private/public`是限制了代理服务器是否可以缓存。

1.  网络安全有了解过吗？CSRF攻击和XSS攻击分别是什么？怎么尽量避免呢
- 考察：对网络安全的掌握情况，避免出现安全问题


31. 网页首屏加载问题有碰到过吗，为什么会出现这种问题？是怎样解决的？
- 考察：是否有尝试优化提升过页面加载
- 

32. SSR，SSG有接触过没，和我们平时使用框架开发相比有什么优缺点？
- 考察：对SSR,SSG的掌握情况，日常还是有比较多的使用场景


33. 为什么会有浅拷贝和深拷贝的说法？如果让你手动实现一个深拷贝，能讲下大体的思路吗
- 考察：对引用类型的了解，以及对各类数据类型的处理


34.  如何手动实现一个Promise？说一下大体思路。包括resolve, reject, then, catch等就可以。涉及到宏任务，微任务。
- 考察：对Promise的理解掌握程度。对js事件循环的掌握程度    
    
     
35. 简单说一下防抖和节流的实现思路
- 考察：对防抖和节流的理解和掌握程度


36. 哪些情况下会导致内存泄漏？浏览器的垃圾回收机制了解过吗，chrome的v8引擎呢
- 考察：浏览器的内存回收机制


37. 有使用过什么设计模式来写代码吗？大概说一下？
- 考察：对写的代码是否有思考、总结、提升


38. 发布订阅模式和订阅者模式有啥区别？一般是在什么场景下使用的？策略模式呢
- 考察：对发布订阅模式和订阅者模式的掌握情况


39. pnpm是啥，为什么能减小node_modules的体积？能直接替代npm吗
- 考察：对pnpm的了解程度


40. es6中，为啥proxy要和Reflect一起用
- 考察：对proxy和reflect的理解掌握情况


41. js中，===和==有啥区别
- 考察：对===和==的掌握情况，对==会进行的隐式转化的掌握情况


42. 数据类型的判断，原型链
- 考察：对原型链的掌握情况


43. js中精度丢失的问题，怎么解决
- 考察：对js变量的了解程度


44. webpack中，loader和plugin有什么区别？都用过哪些loader，plugin
- 考察：对webpack的掌握情况


45. 有遇到什么坑吗，是怎么解决的
- 考察：对开发经历的一种了解，看是否是背八股文，或者培训出来的


46. 做过比较有成就感的是什么
- 考察：都开发经历的一种了解。 


47. 页面数据很多的时候要怎么处理？如何实现的
- 考察：页面性能优化，虚拟滚动


48. await有使用过吗，如果报错了怎么办
- 考察：es6的掌握情况


49. npm中，依赖库的版本定义怎么看
- 考察：npm的掌握情况


50. npm run 执行脚本的过程是啥
- 考察：npm 执行的掌握情况


51.  Git中，merge和rebase有啥区别
- 考察：git的掌握情况


52.  Git中，cherry-pick用过吗，是做啥的
- 考察：git的掌握情况

53.  ts中，interface和type有啥区别
- 考察：ts的掌握情况


54.  说下你对ts中泛型的理解
- 考察：ts的掌握情况


55.  简单介绍下ts中的高级类型
- 考察：ts的掌握情况

56.  