## Garbage Collecation
- js具有自动垃圾回收机制
- 主要是为了实现内存资源的循环利用，避免资源被消耗完，导致系统崩溃。
- 每次在创建Object, String, Array时，都需要分配、消耗内存资源来存储。像这样动态分配了内存资源，最终都要将它们释放，让它们能够再被利用。否则，js的解释器就会很快消耗完系统中的所有可用内存资源，造成系统崩溃
- 垃圾回收机制的大体思路，就是找出不再被使用的变量，释放掉其占用的内存资源。但这个过程开销比较大，所以不是时时的，会按照固定的时间间隔周期性执行

## 垃圾回收机制
- 常见的垃圾回收有两种方式：`标记清除`,`引用计数`
- `标记清除`比较常用
- `引用计数`很少用了现在

### 标记清除
- 当变量进入执行环境时，会被标记为"进入环境"。在离开环境时，则将其标记为"离开环境"
- 逻辑上讲，永远不能释放进入环境的变量所占用的内存。因为只要执行流进入环境，就可能用到这些变量
```js
// 将m, n, func()标记进入环境
let m = 1; 
let n = 2;
function func(a, b){
    a++;
    let c = a + b;
    return c;
}

// 将a, b, c标记为进入环境
func(m, n);
// 将a, b, c标记离开环境，等待垃圾回收
```
- 何时开始回收：一般来说，未引用的对象不会被立即回收，而是垃圾对象一直累计到内存耗尽为止。但内存耗尽，程序将被挂起，垃圾回收开始执行
- 标记清除算法的缺陷
  1. 那些无法从根对象查询到的对象将被清除
  2. 垃圾收集后可能会造成大量的**内存碎片**

### 引用计数
- 语言引擎有一张“引用表”，记录内存中所有资源（通常是各种值）的引用次数。
- 如果一个变量的引用次数变为0, 表明这个值不会再被用到，因此这个值占用的内存将被释放
- 如果一个值不再被需要，但是引用次数却不为0，垃圾回收机制无法释放这个值占用的内存，就会导致内存泄漏
```js
var arr = [1,2,3]; // arr对[1,2,3]进行了引用，引用计数为1
arr = [2,3,4]; // arr对另外的[2,3,4]进行了引用，[1,2,3]的引用计数变为了0，可以被回收
```
- `循环引用`问题：下面函数执行完后，返回值为undefined，所以整个函数以及内部变量都应该被回收。但根据引用计数方法，obj1和obj2的引用计数都不为0，所以它们不会被回收
```js
function func(){
    let obj1 = {};
    let obj2 = {};

    obj1.a = obj2;
    obj2.a = obj1;
}
```
- 解决循环引用的问题，最好就是在不使用它们的时候手动将它们设置为空

## Chrome V8 垃圾回收算法
- 采用分代回收策略，和JAVA的回收策略一致
- 通过区分`临时`和`持久`对象，多回收**临时对象区（新生代）**，少回收**持久对象区（老生代）**，减少每次遍历的对象，从而减少每次GC的耗时

### V8内存限制
- **node**中，js能使用的内存是有限制的
  1. 64位下约为1.4G，32位下约为0.7G
  2. 对应分代内存中，64位下，新生代32MB，老生代1.4G；32位下，新生代16MB，老生代0.7GB
- 新生代内存会被平均分成两个部分，叫`semispace`。
- 这个限制可以通过参数`--max-old-space-size` 和 `--max-new-space-size`调整设置
- 内存限制的原因：处理时间上的限制。以 1.5GB的垃圾回收堆内存为例，v8做一次小的垃圾回收需要50ms左右，做一次非增量的垃圾回收甚至要1s以上。这是垃圾回收中引起js线程暂停执行的时间。在这样的时间花销情况下，应用的性能和响应能力都直线下降

### v8的分代回收
### 新生代算法
- 新生代的算法叫Scavenge，主要采用了Cheney算法。
- 思路:
  1. 将新生代内存平均分为两份，都叫`semispace`。其中一份是**使用**状态(又叫From)，另一个是**闲置**状态(又叫To)。
  2. 分配内存时，在**使用**状态内存中进行分配。
  3. 当开始新生代垃圾回收时，检测**使用**状态的内存，将还被使用的对象复制到**闲置**状态的内存中，将没被使用的对象的内存资源释放。
  4. 检测完后，两块内存角色互换，**闲置**状态的内存变成**使用**状态，**使用**状态的内存变成**闲置**状态
- 晋升：
  1. 当新生代内存中，一个对象经过多次复制，仍然存活，则会被认为是生命周期比较长的变量，随后会被移动到老生代内存中，采用另外的算法管理。这就是晋升。
  2. From内存中的对象在复制到To内存中时，会进行检查。在一定条件下，如果该对象被判定为生命周期较长，会被移动到老生代内存中，而不是到To内存中
  3. 条件：一是对象是否经历过新生代回收，二是To内存的空间占比超过25%限制。
  4. 设置25%限制的原因：如果To内存的空间占比超过25%，在转为From内存的时候，会影响后续内存的分配。
- 缺陷：
  1. 只能使用堆内存的一半。这是由划分空间和复制机制决定的
  2. 是典型的空间换时间的算法，所以无法大规模的应用到所有垃圾回收上
- 优点：
  1. 在时间效率上有优异表现，因为只复制存活对象，且对于生命周期短的场景的存货对象只占少数
  2. 非常适合新生代的内存回收的场景

### 老生代算法
- 老生代算法不适合Scavenge有2个原因：一是存活对象比较多，复制对象效率会变慢；二是内存空间将被浪费一半。
- 老生代中主要采用`Mark-Sweep`和`Mark-Compact`相结合的方式

#### Mark-Sweep
- Mark-Sweep, 标记清除，分为`标记`和`清除`两个阶段。
- 过程：
  1. 在`标记`阶段，遍历所有对象，并只标记存活对象
  2. 在`清除`阶段，清除所有没有被标记的对象
- Scavenge是只复制存活的对象，Mark-Sweep是只清除没被标记的死亡对象
- 活对象在新生代中只占很小一部分，死对象在老生代中只占很小一部分。所以两者效率都很高
- 问题：在进行一次标记清除回收后，会造成大量的内存碎片，会对后续的内存分配造成问题。比如需要为一个对象分配一个大内存，但是此时的内存都是碎片状，没有一片内存碎片能满足。此时会提前触发内存回收。但是内存回收开销比较大。

#### Mark-Compact
- Mark-Compack, 标记整理，为了解决Mark-Sweep的内存碎片问题
- 和Mark-Sweep区别：在`清除`阶段清除死亡对象时，会将存活对象往一端移动。移动完成后，直接清理掉边界外的内存。

### Scavenge, Mark-Sweep, Mark-Compact的对比
| 算法 | Scavenge | Mark-Sweep | Mark-Compact |
| --- | --- | --- | --- |
| 速度 | 最快 | 中等 | 最慢 |
| 空间开销 | 双倍空间，无碎片 | 少，但有碎片 | 少，但无碎片 |
| 是否移动对象 | 是 | 否 | 是 |
- V8中，对老生代算法，主要采用Mark-Sweep。只有在存活对象从新生代移动到老生代内存中时，才会采用Mark-Compact进行内存整理

## Incremental Marking，增量式标记回收
- Scavenge, Mark-Sweep, Mark-Compact在执行时，都需要将应用逻辑停下来，以保证js应用逻辑和垃圾回收器看到的不一致。等垃圾回收执行完后，再恢复js应用逻辑的执行。这种叫做`stop-the-world`全停顿。
- 对于新生代来说，因为默认配置的空间比较小，所以执行起来比较快，全停顿影响不大。
- 对老生代来说，要清理的对象比较多，所以全停顿一次耗时比较长，会造成卡顿的问题
- 为降低全堆垃圾回收带来的全停顿影响，从`标记`阶段入手，将原本需要一次性完成的标记动作改成增量标记，也就是拆分成很多小部分。每完成一个小部分，就让js逻辑执行一会。
- 垃圾回收与应用逻辑交替执行直到标记阶段完成
- 经过增量标记的改善后，垃圾回收的最大停顿时间可以减少到原来的1/6左右
- V8后续在`清理`阶段，还引入延迟清理与增量式清理,让清理动作也变成增量式的。
- 还计划引入并行标记和并行清理，进一步利用多核性能降低每次停顿的时间

## 哪些情况引起内存泄漏
- 意外的全局变量。当声明的变量意外变成全局时(比如变量提升)，只能等页面关闭时才被销毁释放
- 被遗忘的计时器或者回调函数。下面代码中有计时器`setInterval`，且回调函数中有对标签元素ele的引用和对someResource的处理。因此就算标签元素ele从页面中移除，因为该计数器的存在，ele占用的资源和外部变量someResource都不会被释放
```js
let someResource = new Date();
setInterval(()=>{
    let ele = document.getElementById('ele');
    if(ele){
        node.innerHTML = JSON.stringify(someResource);
    }
},1000);
```
- 闭包。闭包可以维持函数内的变量，使其不会被释放。解决方法：解除闭包。
- 没有清除DOM元素的引用。有时缓存DOM元素内部数据结构很有用。但是没用时没有及时清除该缓存，就算移除了页面中该DOM元素，该dom元素占用的内存还是不会被释放

## 避免内存泄漏
- 减少不必要的全局变量，或者生命周期较长的对象
- 及时对无用的数据进行垃圾回收
- 注意程序逻辑，避免死循环
- 避免创建过多的对象

## 检测内存泄漏
- 使用Chrome dev tool的performance

## 垃圾回收的使用场景优化
- Array数组优化。将空数组[]赋值给无用的数组对象，这样虽然将原来的数组值的内存释放，但同时也占用了一个空数组值得内存。最好的方式是`arr.length = 0`
- 对象尽量复用。特别是循环等地方出现创建新的对象，能复用就复用。不用的对象就设置为null。
- 在循环中的函数表达式，能复用的，尽量放到循环外。
```js
// 不好的写法
for(let i of []){
    let func = function(value){

    }
    func(i);
}

// 推荐
let func = function(value){}
for(let i of []){
    func(i)
}
```

## 减少垃圾回收对性能的影响
- 让垃圾回收尽量少的运行，尤其是全堆垃圾回收
- 避免内存泄漏，让内存及时得到释放

## 参考
- https://juejin.cn/post/6844903833387155464
- https://juejin.cn/post/6844903781079973902