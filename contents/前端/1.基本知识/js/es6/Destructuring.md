## Destructuring解构
- ES6 允许按照一定模式，从**数组**和**对象**中提取值，对变量进行赋值
- 解构赋值允许指定默认值.只有当一个数组成员严格等于`undefined`，默认值才会生效。
- 如果默认值是一个表达式，那么这个表达式是**惰性求值**的，即只有在用到的时候，才会求值
- 字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。
- 解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。
```js
let {toString: s} = 123;
s === Number.prototype.toString // true
let {toString: s} = true;
s === Boolean.prototype.toString // true
```
- 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象
- 由于`undefined`和`null`无法转为对象，所以对它们进行解构赋值，都会报错。
- 函数的参数也可以使用解构赋值。

## 圆括号问题
- 对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。
- ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。
- 但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。

### 不能使用圆括号的情况
- 变量声明语句
```js
// 全部报错
let [(a)] = [1];
let {x: (c)} = {};
let ({x: c}) = {};
let {(x: c)} = {};
let {(x): c} = {};
let { o: ({ p: p }) } = { o: { p: 2 } };
```
- 函数参数
```js
// 报错
function f([(z)]) { return z; }
// 报错
function f([z,(x)]) { return x; }
```
- 赋值语句的模式
```js
// 全部报错
({ p: a }) = { p: 42 };
([a]) = [5];
```

### 可以使用圆括号的情况
- 赋值语句的非模式部分，可以使用圆括号。
```js
[(b)] = [3]; // 正确
({ p: (d) } = {}); // 正确
[(parseInt.prop)] = [3]; // 正确
```

## 用途
- 交换变量的值
- 从函数返回多个值
- 函数参数的定义
- 提取 JSON 数据
- 函数参数的默认值
- 遍历 Map 结构
- 输入模块的指定方法