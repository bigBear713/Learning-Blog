## 作用域
- 限制变量和方法起作用、能被访问的区域和生命周期。
- 分类：全局作用域、模块作用域、函数作用域、块级作用域
  1. 全局作用域：范围最广，是最顶层的作用域。
  2. 模块作用域：随着模块化方案(AMD,CommonJS,UMD,ES6等模块)出现而出现。通常一个文件或者一段脚本就是一个模块，它拥有自己独立的作用域。
  3. 函数作用域：一个方法函数相应的作用域。方法函数执行完后，该作用域内的变量、方法函数的生命周期会被结束掉，所占资源会被释放掉。
  4. 块级作用域：代码块相应的作用域。代码块执行完后，该作用域内的变量、方法函数的生命周期会被结束掉，所占资源会被释放掉。ES6才出现。

### 作用域链
- 子级作用域可以访问父级作用域内的变量和方法函数，但是父级作用域无法访问子级作用域内的变量和方法函数。
- 如果当前作用域内找不到所需的变量、方法函数，会逐级往上寻找，直到全局作用域。
- 块级作用域、函数作用域、模块作用域、全局作用域形成链条，就是作用域链。因此调用变量、方法函数时能够逐级往上找，。

### 变量提升
- 使用`var`定义声明变量时，声明行为会提前，赋值则保持不变。
```js
console.log(a); // undefined
var a = 1;
console.log(a); // 1

// 等价于
var a;
console.log(a); // 因此这边打印出的是undefined，而不是报错。
a=1;
console.log(a);
```
- 如果使用`let`(es6)定义变量，则可以避免这个问题。
```js
console.log(a); // 报错，a is not defined
let a = 1;
console.log(a); // 1
```
- 常见的问题场景还有for循环。
```js
for(var i=0;i<10;i++){
    console.log(i);
}
console.log(i); // i=10

// 等价于
var i;
for(i=0;i<10;i++){
    console.log(i);
}
console.log(i); // 因此这边最终会输出10,因为变量i因为变量提升变成提前声明，作用域也跟着提升，不仅仅在for循环中。
```

## 闭包
- 因此父级作用域无法访问子级作用域的变量和方法函数，但是子级作用域可以访问父级作用域的变量和方法函数。所以如果在一个方法函数A内，再定义一个方法函数B，此时B可以访问A的变量和方法函数，因为A的函数作用域高于B的函数作用域。然后再将B方法函数作为A的返回值`return`出来，外部就可以访问A方法函数内的变量、方法函数，此时就形成了闭包。
- 因为方法函数A内的变量、方法函数通过函数B被外部调用，所以无法及时释放资源，可能导致内存泄漏。在使用完后应及时置空释放掉。