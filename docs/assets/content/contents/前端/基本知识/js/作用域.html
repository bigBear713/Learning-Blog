
        <h2 id="%E4%BD%9C%E7%94%A8%E5%9F%9F" class="docs-header-link">
          <span header-link="%E4%BD%9C%E7%94%A8%E5%9F%9F"></span>
          作用域
        </h2>
      <ul>
<li>限制变量和方法起作用、能被访问的区域和生命周期。</li>
<li>分类：全局作用域、模块作用域、函数作用域、块级作用域<ol>
<li>全局作用域：范围最广，是最顶层的作用域。</li>
<li>模块作用域：随着模块化方案(AMD,CommonJS,UMD,ES6等模块)出现而出现。通常一个文件或者一段脚本就是一个模块，它拥有自己独立的作用域。</li>
<li>函数作用域：一个方法函数相应的作用域。方法函数执行完后，该作用域内的变量、方法函数的生命周期会被结束掉，所占资源会被释放掉。</li>
<li>块级作用域：代码块相应的作用域。代码块执行完后，该作用域内的变量、方法函数的生命周期会被结束掉，所占资源会被释放掉。ES6才出现。</li>
</ol>
</li>
</ul>

        <h3 id="%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE" class="docs-header-link">
          <span header-link="%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"></span>
          作用域链
        </h3>
      <ul>
<li>子级作用域可以访问父级作用域内的变量和方法函数，但是父级作用域无法访问子级作用域内的变量和方法函数。</li>
<li>如果当前作用域内找不到所需的变量、方法函数，会逐级往上寻找，直到全局作用域。</li>
<li>块级作用域、函数作用域、模块作用域、全局作用域形成链条，就是作用域链。因此调用变量、方法函数时能够逐级往上找，。</li>
</ul>

        <h3 id="%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87" class="docs-header-link">
          <span header-link="%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"></span>
          变量提升
        </h3>
      <ul>
<li>使用<code>var</code>定义声明变量时，声明行为会提前，赋值则保持不变。</li>
</ul>
<pre class="language-js"><code class="language-js"><div>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// undefined</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span>

<span class="token comment" spellcheck="true">// 等价于</span>
<span class="token keyword">var</span> a<span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 因此这边打印出的是undefined，而不是报错。</span>
a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></div></code></pre>
<ul>
<li>如果使用<code>let</code>(es6)定义变量，则可以避免这个问题。</li>
</ul>
<pre class="language-js"><code class="language-js"><div>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 报错，a is not defined</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span></div></code></pre>
<ul>
<li>常见的问题场景还有for循环。</li>
</ul>
<pre class="language-js"><code class="language-js"><div><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// i=10</span>

<span class="token comment" spellcheck="true">// 等价于</span>
<span class="token keyword">var</span> i<span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 因此这边最终会输出10,因为变量i因为变量提升变成提前声明，作用域也跟着提升，不仅仅在for循环中。</span></div></code></pre>

        <h2 id="%E9%97%AD%E5%8C%85" class="docs-header-link">
          <span header-link="%E9%97%AD%E5%8C%85"></span>
          闭包
        </h2>
      <ul>
<li>因此父级作用域无法访问子级作用域的变量和方法函数，但是子级作用域可以访问父级作用域的变量和方法函数。所以如果在一个方法函数A内，再定义一个方法函数B，此时B可以访问A的变量和方法函数，因为A的函数作用域高于B的函数作用域。然后再将B方法函数作为A的返回值<code>return</code>出来，外部就可以访问A方法函数内的变量、方法函数，此时就形成了闭包。</li>
<li>因为方法函数A内的变量、方法函数通过函数B被外部调用，所以无法及时释放资源，可能导致内存泄漏。在使用完后应及时置空释放掉。</li>
</ul>
