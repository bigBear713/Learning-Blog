
        <h2 id="guard%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB" class="docs-header-link">
          <span header-link="guard%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB"></span>
          guard路由守卫
        </h2>
      <ul>
<li>全局路由守卫函数：<code>beforeEach</code>，<code>afterEach</code></li>
<li>单个路由守卫函数：<code>beforeEnter</code></li>
<li>组件内路由守卫函数：<code>beforeRouteEnter</code>, <code>beforeRouteLeave</code>, <code>beforeRouteUpdate</code></li>
</ul>
<hr>

        <h2 id="%E5%85%A8%E5%B1%80%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%E5%87%BD%E6%95%B0" class="docs-header-link">
          <span header-link="%E5%85%A8%E5%B1%80%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%E5%87%BD%E6%95%B0"></span>
          全局路由守卫函数
        </h2>
      
        <h3 id="beforeeach" class="docs-header-link">
          <span header-link="beforeeach"></span>
          beforeEach
        </h3>
      <ul>
<li>是一个全局的before钩子函数</li>
<li>每次、每个路由改变前，都需执行一次</li>
<li>参数<ol>
<li>to - Route路由对象，即将要进入的目标</li>
<li>from - Route路由对象，当前导航正要离开的路由</li>
<li>next - Function函数，通过调用该函数resolve这个钩子，才能到下一步。参数为空时，会到下一个钩子。如果已经是最后一个钩子，路由的状态就变成<code>confirm</code></li>
</ol>
</li>
</ul>

        <h3 id="aftereach" class="docs-header-link">
          <span header-link="aftereach"></span>
          afterEach
        </h3>
      <ul>
<li>是一个全局的after钩子函数</li>
<li>在页面加载之后执行。而 <code>beforeEach</code> 是在页面加载之前执行</li>
<li>参数和 <code>beforeEach</code> 一样</li>
</ul>
<hr>

        <h2 id="%E5%8D%95%E4%B8%AA%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%E5%87%BD%E6%95%B0beforeenter" class="docs-header-link">
          <span header-link="%E5%8D%95%E4%B8%AA%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%E5%87%BD%E6%95%B0beforeenter"></span>
          单个路由守卫函数beforeEnter
        </h2>
      <ul>
<li>进入某个路由时执行</li>
<li>参数和 <code>beforeEach</code> 一样</li>
</ul>
<hr>

        <h2 id="%E7%BB%84%E4%BB%B6%E5%86%85%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%E5%87%BD%E6%95%B0" class="docs-header-link">
          <span header-link="%E7%BB%84%E4%BB%B6%E5%86%85%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%E5%87%BD%E6%95%B0"></span>
          组件内路由守卫函数
        </h2>
      <ul>
<li>写在组件内，在组件内执行</li>
</ul>

        <h3 id="beforerouteenter" class="docs-header-link">
          <span header-link="beforerouteenter"></span>
          beforeRouteEnter
        </h3>
      <ul>
<li>在渲染该组件的对应路由被 <code>confirm</code> <strong>前</strong>调用</li>
<li>无法获取组件实例<code>this</code>，因为钩子执行前，组件实例还没创建</li>
<li>参数和 <code>beforeEach</code> 一样</li>
</ul>

        <h3 id="beforerouteupdate" class="docs-header-link">
          <span header-link="beforerouteupdate"></span>
          beforeRouteUpdate
        </h3>
      <ul>
<li>在当前路由改变前，但是该组件被复用时调用。比如对于一个带有动态参数的路由<code>/foo/:id</code>，在<code>/foo/1</code>和<code>/foo/2</code>之间跳转的时候，由于会渲染同一个组件，所以组件实例会被复用</li>
<li>能够访问组件实例<code>this</code></li>
<li>参数和 <code>beforeEach</code> 一样</li>
</ul>

        <h3 id="beforerouteleave" class="docs-header-link">
          <span header-link="beforerouteleave"></span>
          beforeRouteLeave
        </h3>
      <ul>
<li>导航离开当前组件的对应路由时调用</li>
<li>可以访问组件实例<code>this</code></li>
<li>参数和 <code>beforeEach</code> 一样</li>
</ul>
